---
layout: post-math-cn
title:  "线代导论 02：求解线性方程"
categories: 线性代数
tags: 线性代数导论 线性方程 消元 逆矩阵 LU分解 转置矩阵 置换矩阵
author: buzzyrain
mathjax: true
---

* content
{:toc}

**线性**代数的最关注的问题是怎样解一个**线性**方程组，线性指的是未知数们仅会被乘上常数 $ cx $，而不是另一个未知数，像 $ x \cdot y $。

我们先看一个小小的二元一次方程：

*[二元一次]: 线性的再次确认

$$
\left\{
\begin{array}{c}
x - 2y = 1 \\
3x + 2y = 11 \\
\end{array}
\right.
\tag{1}\label{1}
$$

准备从三个不同的切入点求解它：①行 ②列 ③矩阵。




## 三个角度

1. **行**视角 <br>
    方程 $ (\ref{1}) $ 里的每一行都是 $ xy $ 平面上的一条直线，方程的解是两条直线的交点。<br>
    ![row-picture](https://wx2.sinaimg.cn/large/9f1c5669gy1ftmkpbxgw9j20lf0c2wij.jpg "ROW"){:class="row mx-auto d-block"}

2. **列**视角<br>
    将列**向量**作为方程的元素，列向量的线性组合恰好等于 $ \boldsymbol{b}  $，

    $$
        x\begin{bmatrix}  1 \\ 3  \\ \end{bmatrix} +
        y\begin{bmatrix} -2 \\ 2  \\ \end{bmatrix} =
         \begin{bmatrix}  1 \\ 11 \\ \end{bmatrix} = \boldsymbol{b}
    $$

    当正确选择了 $ x = 3, \ y= 1 $ (与**行视角中的直线交点**一致)后，我们惊喜的发现 :poop:，$ 3(column 1) + 1 (column 2) = \boldsymbol{b} $。

    ![column-picture](https://wx4.sinaimg.cn/large/9f1c5669gy1ftmko7ji0cj20xg0hxn6w.jpg "COLUMN"){:class="row mx-auto d-block"}

    强调一下，左侧的向量方程仍是**线性组合**，有着两个基本操作，①分别**乘**以3和1 ②然后**加**在一起。

3. **矩阵**视角 <br>
    最后整体看一下方程左边，有一个系数矩阵 (coefficient matrix) $ A_{2 \times 2} $ ，

    $$
    A =
    \begin{bmatrix}
    1 & -2 \\
    3 & 2  \\
    \end{bmatrix}
    $$

    加上两个未知数 $ x, \ y $，得到真正的矩阵问题 $ A \boldsymbol{x} = \boldsymbol{b}  $，

    $$
    A \boldsymbol{x} = \boldsymbol{b} \qquad
    \begin{bmatrix}
    1 & -2 \\
    3 & 2  \\
    \end{bmatrix}
    \begin{bmatrix}  x \\ y  \\ \end{bmatrix} =
    \begin{bmatrix}  1 \\ 11 \\ \end{bmatrix}
    $$


### 三元一次再应用

刚才以二元方程为例，现在用稍加复杂（并没有）的三元一次方程再练习一次，感受一下哪个视角比较明晰。
三个未知数 $ x,\ y, \ z $，三个线性方程，

$$
A \boldsymbol{x} = \boldsymbol{b} \qquad
\left\{
\begin{aligned}
 x + 2y + 3z &= 6 \\
2x + 5y + 2z &= 4 \\
6x - 3y +  z &= 2
\end{aligned}
\right.
\tag{2}\label{2}
$$

这三个未知数 $ x,\ y, \ z $ 可能有解，也可能无解，通常方程数和未知数相等时有解。

1. 行视角 <br>
    三个平面相交于一点。
    ![row-picture-3-eqs](https://wx3.sinaimg.cn/large/9f1c5669gy1ftnloy6eihj20je097n1x.jpg "Three equations in row picture"){:class="row mx-auto d-block"}

2.  <span id="to-col-picture">列视角</span><br>
    列向量的结合

    $$
        x\begin{bmatrix}  1 \\ 2  \\ 6   \\ \end{bmatrix} +
        y\begin{bmatrix}  2 \\ 5  \\ -3  \\ \end{bmatrix} +
        z\begin{bmatrix}  3 \\ 2  \\ 1   \\ \end{bmatrix} =
        \begin{bmatrix}   6 \\ 4  \\ 2  \\ \end{bmatrix} = \boldsymbol{b}
    $$

    **立刻**发现 $ \boldsymbol{b} = (6,\ 4,\ 2) $ 刚好是第三列的两倍。答案昭然若揭，$ x = 0,\ y = 0,\ z = 2 $。<br>

    ![col-picture-3-eqs](  http://wx3.sinaimg.cn/large/9f1c5669gy1ftnlv3erxej20fb098djk.jpg "Three equations in column picture"){:class="row mx-auto d-block"}


3. 矩阵视角 <br>
    写成整块矩阵的形式，$ A \boldsymbol{x} = \boldsymbol{b} $， 其中 $ A $ 是 $ 3 \times 3 $ 的系数矩阵。

    $$
    A \boldsymbol{x} = \boldsymbol{b} \qquad
    \begin{bmatrix}
    1 &  2 & 3  \\
    2 &  5 & 2  \\
    6 & -3 & 1  \\
    \end{bmatrix}
    \begin{bmatrix}  x \\ y  \\ z \\ \end{bmatrix} =
    \begin{bmatrix}  6 \\ 4  \\ 2 \\ \end{bmatrix}
    $$


### Python中的矩阵乘法

[`Numpy`](http://www.numpy.org/)是科学计算的基石，`import numpy as np`是我们熟悉的好旁友！<br>
我们以它的矩阵操作为例，

```python
import numpy as np

# Matrix init
A = np.array([[1, 2, 3], [2, 5, 2], [6, -3, 1]])
x = np.array([[0, 0, 2]]).T;
# >>> OUT
# A: array([[ 1,  2,  3],
#           [ 2,  5,  2],
#           [ 6, -3,  1]])
# x: array([[0],
#           [0],
#           [2]])

# Three ways for matrix multiplication
b1 = np.dot(A, x)
b2 = A @ x
b3 = np.matmul(A, x);
# >>> OUT
# b1 == b2 == b3: array([[6],
#                        [4],
#                        [2]])

# WARNING
b_broadcast = A * x;
# >>> OUT
# b_broadcast: array([[ 0,  0,  0],
#                     [ 0,  0,  0],
#                     [12, -6,  2]])
```

#### 注意
{: .no_toc}

1. `*`运算符在`np.array`中是矩阵**元素**乘法，有[**broadcast**](https://docs.scipy.org/doc/numpy-1.13.0/user/basics.broadcasting.html)机制，即两个逐元素操作的矩阵不需要形状严格相等，其中一个矩阵的某一维度可以是1，只要最终**广播**后的形状一致，运算就会顺利进行。如果与原意不符，能错得措不及防，所以多加小心。

1. 矩阵乘法最好使用`np.matmul`或者`a @ b`，`np.dot`的适用范围见[文档](https://docs.scipy.org/doc/numpy-1.14.0/reference/generated/numpy.dot.html)。

1. 构建矩阵的时候，也可以用`np.mat`，但此时的矩阵乘法在[`np.matrix`](https://docs.scipy.org/doc/numpy-1.14.0/reference/generated/numpy.matrix.html#numpy.matrix)语境下就是`*`算符。

    ```python
    A = np.mat('1, 2, 3; 2, 5, 2; 6, -3, 1')
    b = np.mat('6, 4, 2').T
    x = np.linalg.solve(A, b);

    # IMPORTANT
    b = A * x
    ```


## 初见消元

消元法 (Elimination) 是一种**系统性 (systematic)** 的方法求解线性方程。

*[系统性 (systematic) ]: 有条不紊

![elimination](https://wx1.sinaimg.cn/large/9f1c5669gy1ftptkcqkc9j20ii02hdh3.jpg "Elimination"){:class="row mx-auto d-block"}

消元后，第一个方程中的未知数 $ x $ 在第二个方程中就消去了，变成了 $ 8y = 8 $，立刻可以得出 $ y = 1 $，再代回方程一，解出 $ x = 3 $。所以整个方程组的解是 $ (x,\ y) = (3,\ 1) $。

消元法 ①会产生**上三角形**，就像图中蓝色标记的直角三角形；②**反向代换 (back subtitution)**，从下向上的代换。在刚才的例子里，第二个方程解出 $ y = 1 $ 后，**向上**代入第一个方程。

消元前后的方程组虽然不完全相同，但解确是一样的，都相交于点 $ (3,\ 1) $。

![elimination-row-picture](https://wx4.sinaimg.cn/large/9f1c5669gy1ftpu4rkz21j20jh05pn07.jpg "Elimination row picture"){:class="row mx-auto d-block"}


### 怎样消元

首先看两个概念：

1. 主元（pivot）：一行中，第一个非零的元素，作为消元乘数的分母。
2. 乘数（multiplier）：$ \frac{待消元行中主元的同列元素}{主元} $，如 $ \cfrac{a_{21}}{a_{11}} $。

将方程组的第一个式子改为 $ 4x - 8y = 4 $，虽然是同一条直线，但主元从 $1$ 改为 $4$，乘数从 $\frac{3}{1}$ 变为 $ \frac{3}{4}$。

![elimination-multiplier](https://wx4.sinaimg.cn/large/9f1c5669gy1ftpuy4o9axj20fi023q3z.jpg "Multiplier change to 3/4"){:class="row mx-auto d-block"}


### 消元的失败

想要解出 $ n $ 个方程，我们就要 $ n $ 个主元。这些主元消元后会排列在主对角线上，是上图蓝色三角形的斜边。
而**零是永远不能作为主元的**，否则解方程时除以零，很尴尬。

- 失败：对于 $ n $ 个方程，没有得到 $ n $ 个主元。
    - 出现方程 $ 0 \neq 0 $ （无解）
    - 出现方程 $ 0 = 0 $ （无数解）
- 成功：对于 $ n $ 个方程，恰好得到 $ n $ 个主元，行交换是OK的。<br>
    下图就是一个改过自新的例子，原来方程一的主元上是零。
    ![zero-in-pivot](https://wx2.sinaimg.cn/large/9f1c5669gy1ftpvp6mri8j20fj02f756.jpg "Zero in pivot"){:class="row mx-auto d-block"}


### 从 $A$ 到 $U$

当方程组变得复杂时，变成 $ A_{3 \times 3}\ or\ A_{n \times n} $，不要担心，消元的步骤是一样的。我们能确认的事情不多，小了说有不确定性原理，宏观的有人，但消元法可以带来一点安慰。

总结一下，
- 第1列：用方程一得到第一个主元（$ a_{11} $）下面所有行的**乘数**，乘完相消后**产生零**，即 $ a_{21},\ a_{31}, \cdots ,\ a_{n1} $ 都变成 0。
- 第2列：用新的方程二得到第二个主元（$ a_{22} $）下面的所有零。
- 第3-n列：依次消元下去，产生了上三角矩阵（upper triangular）**U**。

![elimination-summary](https://wx4.sinaimg.cn/large/9f1c5669gy1ftpwf3zwf7j20if02xwfq.jpg "Elimination summary"){:class="row mx-auto d-block"}



## 消元矩阵

通过消元矩阵 $ E $（elimination matrices）我们可以感受矩阵乘法是干什么的。$ E $ **作用**于一个向量 $ b $ 或者一个矩阵 $ A $，产生了一个**新的**向量 $ Eb $、**新的**矩阵 $ EA $。

消元矩阵的目的是把前面消元的每一步用一个矩阵来表示。符号写为 $ E_{ij} $，代表从第 $ i^{th} $ 个等式中减去 $ l_{ij} $ 乘以第 $ j^{th} $ 个等式。这一步将等式 $ i $ 中的 $ x_j $ 消去了。

我们下面几节会具体看到，
1. 每一步消元如何表示成一个矩阵乘法，
2. 将每一步 $ E_{ij} $ 合并成一整个消元矩阵 $ E $。
3. 每一步 $ E_{ij} $ 如何通过逆矩阵 $ E_{ij}^{-1} $ 恢复，
4. 将每一步的**逆矩阵** $ E_{ij}^{-1} $ 合并成一整个下三角矩阵 $ L $。


### 矩阵 x 向量

先是一次消元怎样用矩阵表示。

之前提过用[列视角](#to-col-picture)看待矩阵作用于向量 $ A \boldsymbol{x} $。$ A \boldsymbol{x} $ 中的每一个 $ b_i $ 是 $ A $ 的每一行与 $ \boldsymbol{x} $ 的**点积**，即 $ b_i = \sum_{j=1}^{n} a_{ij} x_{j} $。

刚才例子中的第一步消元是：$$ equation(2) - 2 \cdot equation(1) \tag{*}\label{*} $$

$$
\boldsymbol{b} = \begin{bmatrix}  2 \\ 8  \\ 10   \\ \end{bmatrix}
\qquad \Longrightarrow \qquad
\boldsymbol{b_{new}} = \begin{bmatrix}  2 \\ 4  \\ 10  \\ \end{bmatrix}
$$

最关键的一步就是 $ \eqref{*} $ 用矩阵可以表示成：

$$
E =
\begin{bmatrix}
1  &  0 & 0  \\
-2 &  1 & 0  \\
0  &  0 & 1  \\
\end{bmatrix}
\qquad
\boldsymbol{b_{new}}  = E \boldsymbol{b}
$$

![elimination-matrix](https://wx1.sinaimg.cn/large/9f1c5669gy1ftsc80giccj20h402nmyl.jpg "Elimination matrix"){:class="row mx-auto d-block"}

$ E $ 的第一、三行来源于恒等矩阵（Identity Matrix）$ I $，不改变 $ b_1,\ b_3 $；第二行把 $ I $ 中的某个零元素变成乘数 $ -l $。$ E_{ij} $ 比 $ I $ 在位置 $ (i,\ j) $ 多拥有一个非零元素 $ -l $。作用是从第 $ i^{th} $ 个等式中减去 $ l_{ij} $ 乘以第 $ j^{th} $ 个等式，将元素 $ A_{i,\ j} $ 变为零。

$ E_{ij} $ 的效果是很好，但之后就不用了，将每一步消元都表示为一个矩阵太为繁琐，这里的主要目的是**矩阵如何作用于行元素**。

![Eli-vector](https://wx4.sinaimg.cn/large/9f1c5669gy1ftscncoxkmj20j607mgqf.jpg "Elimination on vector"){:class="row mx-auto d-block"}


### 矩阵 x 矩阵

上一小节看到了矩阵与向量的乘法运算，继续用 $ \eqref{*} $ 效果的 $ E $，

![matrix-multiply](https://wx2.sinaimg.cn/large/9f1c5669gy1ftscypi61mj20hy02ewfm.jpg "Matrix multiplication"){:class="row mx-auto d-block"}

$ A $ 的第一行与第三行没变，第二行减去了两倍的第一行。与 $ b_2 - 2b_1 $ 的行为一致。$ A \boldsymbol{x} = \boldsymbol{b} $ 两边都经过消元，有了 $ E(A \boldsymbol{x}) = E \boldsymbol{b} $。而从矩阵乘法的角度看，操作的顺序是 $ (EA) \boldsymbol{x} = E \boldsymbol{b} $。其实括号是不必要的，它们都一样，$ E(A \boldsymbol{x}) = (EA) \\boldsymbol{x} $。这就是矩阵乘法的结合律。

但是交换律通常是不成立的，$ EA \neq AE $。当右乘 $ E $，它作用在 $ A $ 的**列**上，而不是**行**，$ AE $ 实际上让第二列减去了两倍的第一列。

简单来说，矩阵乘法的规律是，
- 结合律（Associative Law）&emsp; $ A(BC) = (AB)C $
- 交换律（Commutative Law）&emsp; $ Often\ AB \neq BA $


上述操作从**行**理解矩阵乘法，我们还可以从**列**看。假设 $ B $ 仅有一列，$ B = [\ \\boldsymbol{b} \ ] $，$ EB $（矩阵 x 矩阵）的法则应该与 $ E \boldsymbol{b}  $（矩阵 x 向量）完全一致。甚至可以推广至，在 $ EB $ 中以**列**为单位乘。如 $ B $ 中有几列 $ \boldsymbol{b_1},\ \boldsymbol{b_2},\ \boldsymbol{b_3}$，那 $ EB $ 的列应为 $ E\boldsymbol{b_1},\ E\boldsymbol{b_2},\ E\boldsymbol{b_3}$。

**矩阵乘法**

$$
AB = A[\ \boldsymbol{b_1},\ \boldsymbol{b_2}, \ \boldsymbol{b_3} \ ] =
[\ A\boldsymbol{b_1},\ A\boldsymbol{b_2}, \ A\boldsymbol{b_3} \ ]
$$

至此，矩阵乘法的三个方法（行、列，整个矩阵）已经介绍了两种。


### 行交换矩阵

$ P_{ij} $ 是一个第 $ i $ 行与第 $ j $ 行调换的恒等矩阵 $ I $。当行交换矩阵（permutation matrix）左乘一个矩阵，它的功效就是交换第 $ i $ 行与第 $ j $ 行。

例如，$ P_{23} $ 是 $ I $ 的二、三行互换，

$$
P_{23} =
\begin{bmatrix}
1  &  0 & 0  \\
0  &  0 & 1  \\
0  &  1 & 0  \\
\end{bmatrix}
$$

$ P_{23} $ 交换了矩阵（包括向量）的二、三行，

![permutation](https://wx2.sinaimg.cn/large/9f1c5669gy1ftsyumajbgj20h302laba.jpg "Permutation"){:class="row mx-auto d-block"}

行交换矩阵不是必须要的，但消元时主元位置如果出现了零，就需要它将下面行的非零主元移至对角线。


### 增广矩阵

矩阵会有各种各样的现实应用，都离不开乘法操作。我们在消元的过程中遇见方阵 $ E $ 乘方阵 $ A $，现在只要将 $ A \boldsymbol{x} = \boldsymbol{b} $ 中的 $ \boldsymbol{b} $ 作为额外的一列 $ [\ A\ \boldsymbol{b}\ ] $ ，方阵就成了矩形阵（rectangular matrix），也叫做增广矩阵。

乘法法则的同样可以应用于增广矩阵，
- 行（ROWS）：$ E $ 的**每一行**施法于 $ [\ A\ \boldsymbol{b}\ ] $，有 $ [\ EA\ E\boldsymbol{b}\ ] $。
- 列（COLUMNS）：$ E $ 整个施法于$ [\ A\ \boldsymbol{b}\ ] $ 的**每一列**，有 $ [\ EA\ E\boldsymbol{b}\ ] $。

*[施法]: 矩阵真的做了实事，作用于向量产生新向量，作用于矩阵产生新矩阵。


### 消元的总结
{: .no_toc}

最后回到消元，现在能看出整个消元过程实际上是一系列的行操作，相当于矩阵乘法，$ A \Longrightarrow E_{21}A \Longrightarrow E_{31}E_{21}A$, 最后 $ E_{32}E_{31}E_{21}A $ 成了一个上三角矩阵。


### 练习
{: .alert .alert-exercise-heading .text-center}

Q1. $$
A =
\begin{bmatrix}
3 & 4 \\
1 & 5 \\
2 & 0 \\
\end{bmatrix}, \
B =
\begin{bmatrix}
2 & 4 \\
1 & 1 \\
\end{bmatrix}
$$
，用行、列两种乘法思路的求解 $ AB $ 。
{: .alert .alert-question}

<div markdown="1">
  <button class="btn btn-info" type="button" data-toggle="collapse" data-target="#collapseSolution1" aria-expanded="false" aria-controls="collapseSolution1">
    两种乘法的结果是一致的
  </button>
  <div class="collapse" id="collapseSolution1">
    <img class="row mx-auto d-block" src="https://wx2.sinaimg.cn/large/9f1c5669gy1ftt10ycvb1j20ke0d6gv0.jpg" alt="2-ways-for-matrix-multiplication">
  </div>
</div>


Q2. $ P_{13}AP_{13} $，其中
$$
A =
\begin{bmatrix}
1  &  2 & 3  \\
4  &  5 & 6  \\
7  &  8 & 9  \\
\end{bmatrix},\
P_{13} =
\begin{bmatrix}
0  &  0 & 1  \\
0  &  1 & 0  \\
1  &  0 & 0  \\
\end{bmatrix}
$$
{: .alert .alert-question}

<b>左</b>乘 $ P_{13} $ 操作**行**，`A[0, :], A[-1, :] = A[-1, :].copy(), A[0, :].copy()`，<br>
<b>右</b>乘 $ P_{13} $ 操作**列**，`A[:, 0], A[0, -1] = A[0, -1].copy(), A[:, 0].copy()`。

<div markdown="1">
  <button class="btn btn-info" type="button" data-toggle="collapse" data-target="#collapseSolution2" aria-expanded="false" aria-controls="collapseSolution2">
    交换两次
  </button>
  <div class="collapse" id="collapseSolution2">
    <img class="row mx-auto d-block" src="https://wx2.sinaimg.cn/large/9f1c5669gy1ftt22bhu85j20az07sjs8.jpg" alt="exchange-two-times">
  </div>
</div>


Q3. 如果 $ AB = I \ and \ BC = I $，用结合律证明 $ A = C $。
{: .alert .alert-question}

<div markdown="1">
  <button class="btn btn-info" type="button" data-toggle="collapse" data-target="#collapseSolution3" aria-expanded="false" aria-controls="collapseSolution3">
    结合律展开 $ ABC $
  </button>
  <div class="collapse" id="collapseSolution3">

    $$
    \begin{align}
      ABC &= (AB)C = IC = C \\
          &= A(BC) = AI = A \\
    \end{align}
    \\
    $$
    $$ Therefore, \ A = C $$
  </div>
</div>
